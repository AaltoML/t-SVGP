:py:mod:`src.util`
==================

.. py:module:: src.util

.. autoapi-nested-parse::

   Utilities for the model classes



Module Contents
---------------

.. py:function:: conditional_from_precision_sites_white(Kuu: tensorflow.Tensor, Kff: tensorflow.Tensor, Kuf: tensorflow.Tensor, l: tensorflow.Tensor, L: tensorflow.Tensor = None, L2=None, jitter=1e-09)

   Given a gâ‚ and g2, and distribution p and q such that
     p(gâ‚‚) = N(gâ‚‚; 0, Kuu)

     p(gâ‚) = N(gâ‚; 0, Kff)
     p(gâ‚ | gâ‚‚) = N(gâ‚; Kfu (Kuuâ»Â¹) gâ‚‚, Kff - Kfu (Kuuâ»Â¹) Kuf)

   And  q(gâ‚‚) = N(gâ‚‚; Î¼, Î£) such that
       Î£â»Â¹  = Kuuâ»Â¹  + Kuuâ»Â¹LLáµ€Kuuâ»Â¹
       Î£â»Â¹Î¼ = Kuuâ»Â¹l

   This method computes the mean and (co)variance of
     q(gâ‚) = âˆ« q(gâ‚‚) p(gâ‚ | gâ‚‚) dgâ‚‚ = N(gâ‚‚; Î¼*, Î£**)

   with
   Î£** = k** - kfu Kuuâ»Â¹ kuf - kfu Kuuâ»Â¹ Î£ Kuuâ»Â¹ kuf
       = k** - kfu Kuuâ»Â¹kuf + kfu (Kuu + LLáµ€)â»Â¹ kuf
   Î¼* = k*u Kuuâ»Â¹ m
      = k*u Kuuâ»Â¹ Î›â»Â¹ Kuuâ»Â¹ l
      = k*u (Kuu + LLáµ€)â»Â¹ l

   Inputs:
   :param Kuu: tensor M x M
   :param Kff: tensor N x 1
   :param Kuf: tensor M x N
   :param L: tensor L x M x M
   :param l: tensor M x L


.. py:function:: conditional_from_precision_sites(Kuu: tensorflow.Tensor, Kff: tensorflow.Tensor, Kuf: tensorflow.Tensor, l: tensorflow.Tensor, L: tensorflow.Tensor = None, L2=None)

   Given a gâ‚ and g2, and distribution p and q such that
     p(gâ‚‚) = N(gâ‚‚; 0, Kuu)

     p(gâ‚) = N(gâ‚; 0, Kff)
     p(gâ‚ | gâ‚‚) = N(gâ‚; Kfu (Kuuâ»Â¹) gâ‚‚, Kff - Kfu (Kuuâ»Â¹) Kuf)

   And  q(gâ‚‚) = N(gâ‚‚; Î¼, Î£) such that
       Î£â»Â¹  = Kuuâ»Â¹  + LLáµ€
       Î£â»Â¹Î¼ = l

   This method computes the mean and (co)variance of
     q(gâ‚) = âˆ« q(gâ‚‚) p(gâ‚ | gâ‚‚) dgâ‚‚ = N(gâ‚‚; Î¼*, Î£**)

   with
   Î£** = k** - kfu Kuuâ»Â¹ kuf - kfu Kuuâ»Â¹ Î£ Kuuâ»Â¹ kuf
       = k** - kfu Kuuâ»Â¹kuf + kfu Kuuâ»Â¹ (Kuuâ»Â¹  + LLáµ€)â»Â¹ Kuuâ»Â¹ kuf
       = k** - kfu Kuuâ»Â¹kuf + kfu Kuuâ»Â¹ (Kuu - Kuu L(I + Láµ€KuuL)â»Â¹Láµ€ Kuu) Kuuâ»Â¹ kuf
       = k** - kfu L(I + Láµ€KuuL)â»Â¹Láµ€ kuf
       = k** - kfu LWâ»Â¹Láµ€ kuf
       = k** - kfu L Lwâ»áµ€Lwâ»Â¹ Láµ€ kuf
       = k** - (Lwâ»Â¹ Láµ€ kuf)áµ€ Lwâ»Â¹ Láµ€ kuf
       = k** - (D kuf)áµ€ D kuf

   Î¼* = k*u Kuuâ»Â¹ m
      = k*u Kuuâ»Â¹ Î£ l
      = k*u Kuuâ»Â¹ (Kuuâ»Â¹  + LLáµ€)â»Â¹ l
      = k*u Kuuâ»Â¹ (Kuu - Kuu L(I + Láµ€KuuL)â»Â¹Láµ€ Kuu) l
      = k*u l - k*u L(I + Láµ€KuuL)â»Â¹Láµ€ Kuu l
      = k*u l - k*u LWâ»Â¹Láµ€ Kuu l
      = k*u l - (Lwâ»Â¹ Láµ€ kuf)áµ€ Lwâ»Â¹ Láµ€ Kuu l
      = k*u l - (D kuf)áµ€ D Kuu l

   Inputs:
   :param Kuu: tensor M x M
   :param Kff: tensor N x 1
   :param Kuf: tensor M x N
   :param L: tensor L x M x M
   :param l: tensor M x L


.. py:function:: project_diag_sites(Kuf: tensorflow.Tensor, lambda_1: tensorflow.Tensor, lambda_2: tensorflow.Tensor, Kuu: Optional[tensorflow.Tensor] = None, cholesky=True)

   From  Kuu, Kuf, Î»â‚, Î»â‚‚, computes statistics
   L = Kuuâ»Â¹ (Î£â‚™ Kufâ‚™ Î»â‚‚â‚™ Kfâ‚™u) Kuuâ»Â¹
   l = Kuuâ»Â¹ (Î£â‚™ Kufâ‚™ Î»â‚â‚™)

   :param Kuf: L x M x N
   :param lambda_2: N x L
   :param lambda_1: N x L
   :param Kuu: L x M x M

   return:
   l : M x L
   L : L x M x M


.. py:function:: kl_from_precision_sites_white(A, l, L=None, L2=None)

   Computes the kl divergence KL[q(f)|p(f)]

   where:
   q(f) = N(Î¼,Î£) and covariance of a Gaussian with natural parameters
   with
       Î£ = Î›â»Â¹  = (Aâ»Â¹  + Aâ»Â¹LLáµ€Aâ»Â¹)â»Â¹  = A(A + LLáµ€)â»Â¹A
       Î¼ = Î›â»Â¹ Aâ»Â¹l = Î£ Aâ»Â¹l

   p(f) = N(0,A)


.. py:function:: kl_from_precision_sites(A, l, L=None, L2=None)

   Computes the kl divergence KL[q(f)|p(f)]

   where:
   q(f) = N(Î¼,Î£) and covariance of a Gaussian with natural parameters
   with
       Î£ = Î›â»Â¹  = (Aâ»Â¹  + Aâ»Â¹LLáµ€Aâ»Â¹)â»Â¹  = A(A + LLáµ€)â»Â¹A
       Î¼ = Î›â»Â¹ Aâ»Â¹l = Î£ Aâ»Â¹l

   p(f) = N(0,A)


.. py:function:: posterior_from_dense_site(K, lambda_1, lambda_2_sqrt)

   Returns the mean and cholesky factor of the density q(u) = p(u)t(u) = ğ“(u; m, S)
   where p(u) = ğ“(u; 0, K) and t(u) = exp(uáµ€Î»â‚ - Â½ uáµ€Î›â‚‚u)

   P = -2Î›â‚‚

   S = (Kâ»Â¹ + P)â»Â¹ = (Kâ»Â¹ + LLáµ€)â»Â¹ = K - KLWâ»Â¹Láµ€K , W = (I + Láµ€KL)
   m = S Î»â‚

   Input:
   :param: K : M x M
   :param: lambda_1: M x P
   :param: lambda_2: P x M x M

   Output:
   m: M x P
   chol_S: P x M x M


.. py:function:: posterior_from_dense_site_white(K, lambda_1, lambda_2, jitter=1e-09)

   Returns the mean and cholesky factor of the density q(u) = p(u)t(u) = ğ“(u; m, S)
   where p(u) = ğ“(u; 0, K) and t(u) = exp(uáµ€Î»â‚ - Â½ uáµ€Î›â‚‚u)

   S = Î›â‚‚â»Â¹ = (Kâ»Â¹ + Kâ»Â¹PKâ»Â¹)â»Â¹ = = [Kâ»Â¹(K + P)Kâ»Â¹]â»Â¹  = K(K + P)â»Â¹K
   m = S Kâ»Â¹Î»â‚ = K(K + LLáµ€)â»Â¹Î»â‚

   Input:
   :param: K : M x M
   :param: lambda_1: M x P
   :param: lambda_2: P x M x M

   Output:
   m: M x P
   chol_S: P x M x M


.. py:function:: gradient_transformation_mean_var_to_expectation(inputs, grads)

   Transforms gradient ğ  of a function wrt [Î¼, ÏƒÂ²]
   into its gradients wrt to [Î¼, ÏƒÂ² + Î¼Â²]
   :param inputs: [Î¼, ÏƒÂ²]
   :param grads: ğ 
   Output:
   â–½Î¼


