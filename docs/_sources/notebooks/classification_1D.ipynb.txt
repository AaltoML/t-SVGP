{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "5097455e",
   "metadata": {
    "cell_marker": "\"\"\""
   },
   "source": [
    "# 1D Classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "883b573d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import gpflow\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import tensorflow as tf\n",
    "from gpflow import set_trainable\n",
    "from gpflow.optimizers import NaturalGradient\n",
    "from tqdm import tqdm\n",
    "\n",
    "from src.models.tsvgp import t_SVGP"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6cfca454",
   "metadata": {},
   "outputs": [],
   "source": [
    "# For reproducibility\n",
    "rng = np.random.RandomState(123)\n",
    "tf.random.set_seed(42)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ce025478",
   "metadata": {
    "cell_marker": "\"\"\""
   },
   "source": [
    "## Generating toy data for classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ee3815a9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Simulate data\n",
    "func = lambda x: np.sin(12 * x) / x\n",
    "N = 100  # Number of training observations\n",
    "X = rng.rand(N, 1) * 2 - 1  # X values\n",
    "F = func(X) + 0.2 * rng.randn(N, 1)  # Noisy Y values\n",
    "Y = (F > 0).astype(float)\n",
    "\n",
    "# GP parameters\n",
    "var_gp = 0.6\n",
    "len_gp = 0.5\n",
    "\n",
    "x_grid = np.linspace(-1, 1, 100)\n",
    "plt.plot(x_grid, func(x_grid))\n",
    "plt.plot(X, Y, \"o\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2ff83a16",
   "metadata": {
    "cell_marker": "\"\"\"",
    "lines_to_next_cell": 0
   },
   "source": [
    "## Declaring classification model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ad51a9a0",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "# =============================================== Set up models\n",
    "M = 10  # Number of inducing locations\n",
    "Z = np.linspace(X.min(), X.max(), M).reshape(-1, 1)\n",
    "\n",
    "m_t = t_SVGP(\n",
    "    gpflow.kernels.SquaredExponential(lengthscales=len_gp, variance=var_gp),\n",
    "    gpflow.likelihoods.Bernoulli(),\n",
    "    Z,\n",
    "    num_data=N,\n",
    ")\n",
    "\n",
    "m_q_white = gpflow.models.SVGP(\n",
    "    gpflow.kernels.SquaredExponential(lengthscales=len_gp, variance=var_gp),\n",
    "    gpflow.likelihoods.Bernoulli(),\n",
    "    Z,\n",
    "    num_data=N,\n",
    "    whiten=True,\n",
    ")\n",
    "\n",
    "m_q = gpflow.models.SVGP(\n",
    "    gpflow.kernels.SquaredExponential(lengthscales=len_gp, variance=var_gp),\n",
    "    gpflow.likelihoods.Bernoulli(),\n",
    "    Z,\n",
    "    num_data=N,\n",
    "    whiten=False,\n",
    ")\n",
    "\n",
    "set_trainable(m_q_white.kernel.lengthscales, False)\n",
    "set_trainable(m_q.kernel.lengthscales, False)\n",
    "set_trainable(m_t.kernel.lengthscales, False)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3ab517ce",
   "metadata": {
    "cell_marker": "\"\"\"",
    "lines_to_next_cell": 0
   },
   "source": [
    "## Training model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9c7c0521",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "# =============================================== run inference\n",
    "lr_natgrad = 0.8\n",
    "nit = 20\n",
    "\n",
    "data = (tf.convert_to_tensor(X), tf.convert_to_tensor(Y))\n",
    "\n",
    "print(\"Elbos at initial parameter\")\n",
    "\n",
    "[m_t.natgrad_step(data, lr_natgrad) for _ in range(nit)]\n",
    "print(\"t-SVGP elbo:\", m_t.elbo(data).numpy())\n",
    "\n",
    "natgrad_opt = NaturalGradient(gamma=lr_natgrad)\n",
    "training_loss = m_q.training_loss_closure(data)\n",
    "training_loss_white = m_q_white.training_loss_closure(data)\n",
    "\n",
    "# q-SVGP\n",
    "variational_params = [(m_q.q_mu, m_q.q_sqrt)]\n",
    "[natgrad_opt.minimize(training_loss, var_list=variational_params) for _ in range(nit)]\n",
    "print(\"q-SVGP elbo:\", -training_loss().numpy())\n",
    "\n",
    "variational_params_white = [(m_q_white.q_mu, m_q_white.q_sqrt)]\n",
    "[natgrad_opt.minimize(training_loss_white, var_list=variational_params_white) for _ in range(nit)]\n",
    "print(\"q-SVGP (white) elbo:\", -training_loss_white().numpy())\n",
    "\n",
    "elbo = m_t.elbo(data).numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f06b5004",
   "metadata": {
    "cell_marker": "\"\"\""
   },
   "source": [
    "## Computing elbos for new parameter grid"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f7976fa3",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "\n",
    "# ======================================== ELBO for different theta\n",
    "N_grid = 100\n",
    "llh_qsvgp = np.zeros((N_grid,))\n",
    "llh_qsvgp_white = np.zeros((N_grid,))\n",
    "llh_tsvgp = np.zeros((N_grid,))\n",
    "vars_gp = np.linspace(0.05, 1.0, N_grid)\n",
    "\n",
    "for i, v in enumerate(tqdm(vars_gp)):\n",
    "    m_t.kernel.variance.assign(tf.constant(v))\n",
    "    llh_tsvgp[i] = m_t.elbo(data).numpy()\n",
    "    m_q.kernel.variance.assign(tf.constant(v))\n",
    "    llh_qsvgp[i] = m_q.elbo(data).numpy()\n",
    "    m_q_white.kernel.variance.assign(tf.constant(v))\n",
    "    llh_qsvgp_white[i] = m_q_white.elbo(data).numpy()\n",
    "\n",
    "print(\"done.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ce13656e",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# ======================================== Visualize\n",
    "plt.figure()\n",
    "plt.plot(vars_gp, llh_tsvgp, label=\"t-SVGP\", linewidth=4)\n",
    "plt.plot(vars_gp, llh_qsvgp, label=\"q-SVGP\", linewidth=4)\n",
    "plt.plot(vars_gp, llh_qsvgp_white, label=\"q-SVGP (whitened)\", linewidth=4)\n",
    "plt.vlines(\n",
    "    var_gp,\n",
    "    ymin=llh_tsvgp.min() - 10,\n",
    "    ymax=llh_tsvgp.max() + 10,\n",
    "    color=[0, 0, 0, 1.0],\n",
    "    linewidth=1.5,\n",
    "    linestyle=\"dashed\",\n",
    ")\n",
    "plt.xlim([0.0, 1.0])\n",
    "plt.ylim(\n",
    "    [\n",
    "        llh_tsvgp.min() - 0.0 * (llh_tsvgp.max() - llh_tsvgp.min()),\n",
    "        llh_tsvgp.max() + 0.4 * (llh_tsvgp.max() - llh_tsvgp.min()),\n",
    "    ]\n",
    ")\n",
    "plt.legend()\n",
    "plt.xlabel(\"$\\\\theta$\")\n",
    "plt.ylabel(\"ELBO\")\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_markers": "\"\"\""
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
